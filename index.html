
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PixiToy</title>
    <link rel="stylesheet" href="./index.css">

    
    <script type="importmap">
    { "imports": {
        "three":"https://unpkg.com/three@0.161.0/build/three.module.js",
        "three/addons/":"https://unpkg.com/three@0.161.0/examples/jsm/"
    } }
    </script>
    
</head>
<body>

    <div class="intro">
        <div class="cue"></div>
        <div class="top"><img src="../레시피북.png" id="img1"></div>
        <div class="bottom"><img src="../레시피북.png" id="img2"></div>
    </div>

    <div class="content">

        <div id="frst" class="stack">
          <img src="./src/img/fpst.jpg" id="fpst" alt="">
          <div class="frst-content">
            <img src="./src/img/logo.png" class="flogo" alt="logo">
            <p class="research">AR기술을 통해 현실과 가상 세계를 
              연결하여 몰입감 있는 팬시 문구 
              콘텐츠를 제공하는 브랜드 디자인 연구</p>
          </div>
        </div>
  
                
        <div class="line"></div>

        <div id="sec">
          <DIV class="tittle">
            컨텐츠 체험하기
          </DIV>

        

          <!-- 단일 버튼 (현재 슬라이드에 따라 변경) -->
        
        



            <!-- 여기에 실제 콘텐츠 (이미지나 텍스트) -->
        <!-- SVG 코드 직접 삽입 -->
        
            
                
         <div class="ph-viewer-wrap">

          <div class="ph-viewer" id="phViewer" aria-roledescription="carousel" aria-label="이미지 뷰어">

            <div class="ph-slide ph-active" id="phS0" aria-hidden="false">
              <img class="ph-img" src="./src/img/ph.png" alt="투명 이미지 1">
            </div>

            <div class="ph-slide" id="phS1" aria-hidden="true">
              <img class="ph-img" src="./src/img/ph1.png" alt="투명 이미지 2">
            </div>

            <!-- 좌/우 화살표 -->
            <button class="ph-nav ph-left" id="phPrev" aria-label="이전">
              <svg viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" style="transform:rotate(180deg);">
                <polyline points="8 4 16 12 8 20"></polyline>
              </svg>

            </button>
            <button class="ph-nav ph-right" id="phNext" aria-label="다음">
              <svg viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                <polyline points="8 4 16 12 8 20"></polyline>
              </svg>
            </button>

          </div> <!-- 버튼 -->
          <div class="ph-action">
            <a id="phActionBtn" class="ph-btn" href="https://example.com/site-a" target="_blank" rel="noopener"></a>
          </div>
        </div>
        </div>

        <div class="line"></div>
       
        <div id="thr">

          <p class="tittle">브랜딩 소개</p>
          <img src="./src/img/img.png" id="chimg">

          <DIV class="subheading">
            연구 목적 <br>
Research Purpose
          </DIV>
          <p id="rsr">
            스마트 기기의 보편화로 아이들은 점점 아날로그적 감성과 상상력 자극 경험에서 멀어지고 있다. 이에 따라 단순한 문구를 넘어 창의성과 몰입을 유도할 수 있는 새로운 형태의 팬시 문구가 요구된다. 본 브랜드는 AR 기술을 접목하여 아이들에게 문구 이상의 즐거움과 상상력 확장의 기회를 제공하고, 현실과 디지털이 연결된 감성적인 경험을 통해 지속적인 흥미를 유도한다. 또한, 부모들이 신뢰할 수 있는 안전성과 교육적 가치를 함께 담은 브랜드를 지향한다.
          </p>


          <DIV class="subheading">
            체험해보기
          </DIV>
          

          <div class="logo">
            <img class="logos" src="./src/img/logo.png" alt="">
            <img class="logos" src="./src/img/logo1.png" alt="">

            <p>pixie (요정) + toy(장난감)로<br>
요정이 마법을 부리듯, AR을 통해 마법 같은 <br>
경험을 실현하는 팬시 문구를 뜻한다.</p>
          </div>

          <DIV class="subheading">
            로고 디자인<br>
Logo Design
          </DIV>


          <!--캐릭터 소개 부분  -->
        <div class="carousel-wrapper">
            <div class="carousel-container">
              <div class="carousel-items" id="carousel">
                <div class="carousel-item">
                  <img src="./src/img/ch (1).png" alt="캐로셀 1">
                </div>
                <div class="carousel-item">
                  <img src="./src/img/ch (2).png" alt="캐로셀 2">
                </div>
                <div class="carousel-item">
                  <img src="./src/img/ch (3).png" alt="캐로셀 3">
                </div>
                <div class="carousel-item">
                  <img src="./src/img/ch (4).png" alt="캐로셀 4">
                </div>
              </div>
            </div>
          </div>
          <div class="mti">
            <h1>루나 / Luna</h1>
            <p>마법사 고양이 ‘루나’는 아이들의 상상력을 깨우는 안내자입니다. 신비로운 모자와 맑은 눈망울은 마법 같은 세계로 들어가는 문을 상징하며, 언제나 즐겁고 친근하게  AR 체험을 안내합니다.</p>
          </div>










<DIV class="subheading">
            체험해보기
          </DIV>
<!-- 모델링 부분 -->
          <div id="viewer">
      <button id="swapBtn">다른 모델 보기 ▶</button>
    </div>





<div class="purple">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 375.08 81.61" style="display:block; width:100%; height:auto;">
      <path fill="#ffffff" d="M0,0c0,48.26,215.7,94.38,375.08,78.38V0H0Z"/>
    </svg>
    <div class="blnk"></div>



      <DIV class="subheading2">
            체험해보기
          </DIV>

    <div class="slider-wrapper">
      <div class="slider-container" id="slider">
        <div class="slider-item">
          <img src="./src/img/mockup (1).jpg" alt="이미지 1">
        </div>
        <div class="slider-item">
          <img src="./src/img/mockup (2).jpg" alt="이미지 2">
        </div>
        <div class="slider-item">
          <img src="./src/img/mockup (3).jpg" alt="이미지 3">
        </div>
        <div class="slider-item">
          <img src="./src/img/mockup (4).jpg" alt="이미지 4">
        </div>
        <div class="slider-item">
          <img src="./src/img/mockup (5).jpg" alt="이미지 5">
        </div>
        <div class="slider-item">
          <img src="./src/img/mockup (6).jpg" alt="이미지 6">
        </div>
      </div>
      <div class="slider-dots" id="sliderDots"></div>
    </div>

    <DIV class="subheading2">
            체험해보기
          </DIV>
          <img class="pst" src="./src/img/pst.png" alt="">

        

</div>

        </div>
        <div class="line"></div>
<div id="end">
    <DIV class="subheading">
            체험해보기
          </DIV>
  <img src="./src/img/대지 10.png" id="gmic">

  <DIV  class="lsts">
  <H1>35회 동의대학교 디자인조형학과 <br>
  시각디자인전공 졸업전시회<br></H1>
  <p> 
  2025 35TH DONG-EUI UNIV <br>
  VISUAL DESIGN GRADUATIONC EXHIBITION <br><br>
    이름: 윤인구 <br></p>
    </DIV>
</div>















   




    </div>









































    






<!-- 휴대폰 부분_____________________________________________________________________ -->
     <script>
    (function () {
      const slides = [document.getElementById('phS0'), document.getElementById('phS1')];
      const btnPrev = document.getElementById('phPrev');
      const btnNext = document.getElementById('phNext');
      const actionBtn = document.getElementById('phActionBtn');

      const actions = [
        { href: 'https://yooningu.github.io/ar.js-test', label: 'START AR' },
        { href: 'https://yooningu.github.io/suika-game', label: 'START GAME' }
      ];

      let idx = 0;

      function render() {
        slides.forEach((el, i) => {
          el.classList.toggle('ph-active', i === idx);
          el.setAttribute('aria-hidden', i === idx ? 'false' : 'true');
        });
        actionBtn.href = actions[idx].href;
        actionBtn.textContent = actions[idx].label;
      }

      function prev() { idx = (idx + slides.length - 1) % slides.length; render(); }
      function next() { idx = (idx + 1) % slides.length; render(); }

      btnPrev.addEventListener('click', prev);
      btnNext.addEventListener('click', next);

      // 간단한 스와이프 제스처
      let startX = 0, startY = 0, moved = false;
      const viewer = document.getElementById('phViewer');

      viewer.addEventListener('touchstart', (e) => {
        const t = e.touches[0];
        startX = t.clientX; startY = t.clientY; moved = false;
      }, { passive: true });

      viewer.addEventListener('touchmove', (e) => {
        const t = e.touches[0];
        const dx = t.clientX - startX;
        const dy = t.clientY - startY;
        if (!moved && Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > 24) {
          moved = true;
          (dx < 0 ? next : prev)();
        }
      }, { passive: true });

      render();
    })();
    </script>

    <!-- 모델링 부분 ──────────────────────────────────────────────────────── -->
    <script type="module">
      import * as THREE from 'three';
      import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

      const container = document.getElementById('viewer');
      const swapBtn   = document.getElementById('swapBtn');

      // ── 장면/카메라/렌더러 ─────────────────────────────────────────────
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffffff);

      const camera = new THREE.PerspectiveCamera(
        35, // ↓ 원근감 완화 (기존 60보다 덜 왜곡)
        container.clientWidth / container.clientHeight,
        0.01,  // 가까운 면 (클리핑 방지)
        5000   // 먼 면
      );
      camera.position.set(0, 1.2, 3);

      const renderer = new THREE.WebGLRenderer({ antialias:true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      container.appendChild(renderer.domElement);

      // ── 조명 ──────────────────────────────────────────────────────────
      scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 3.3));
      const dir = new THREE.DirectionalLight(0xffffff, 3.6);
      dir.position.set(3,10,10);
      scene.add(dir);

      // ── 컨트롤 ────────────────────────────────────────────────────────
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      // controls.minPolarAngle = Math.PI / 2; controls.maxPolarAngle = Math.PI / 2; // 좌우만 회전 비활성화

    //모델
      const MODELS = [
        {
          url: 'https://yooningu.github.io/ar.js-test/gltf/cat-glb/p-cat.glb',
          scale: 0.01,
          position: { x: 0,   y: 0,   z: 0 },
          rotation: { x: 0,   y: 0,   z: 0 }
        },
        {
          url: 'https://yooningu.github.io/ar.js-test/gltf/cat-glb/cat-glb.glb',
          scale: 0.001,
          position: { x: 0, y: 0,   z: 0 },          // 위치
          rotation: { x: 0, y:0, z: 0 }     //각도
        }
      ];

      const loader = new GLTFLoader();
      const models = [];
      let current = 0;

      // 모델 로드 & 준비
      async function loadModel({ url, scale, position, rotation }) {
        const gltf = await loader.loadAsync(url);
        const model = gltf.scene;
        model.scale.setScalar(scale);

        // 중앙/바닥 정렬 (원점에 모델 중심+바닥 맞춤)
        const box = new THREE.Box3().setFromObject(model);
        const center = box.getCenter(new THREE.Vector3());
        model.position.set(-center.x, -box.min.y, -center.z);

        // 사용자 위치/회전 적용
        model.position.add(new THREE.Vector3(position.x, position.y, position.z));
        model.rotation.set(rotation.x, rotation.y, rotation.z);

        model.visible = false;
        scene.add(model);
        return model;
      }

      // 모델 크기 기반으로 카메라/컨트롤 세팅 (투시 완화 + 과도 확대 방지)
      function frameToObject(object, padding = 1.4) {
        const box = new THREE.Box3().setFromObject(object);
        const size = box.getSize(new THREE.Vector3());
        const center = box.getCenter(new THREE.Vector3());

        // 컨트롤 타겟을 모델 중심 근처로
        controls.target.copy(center);
        controls.target.y = Math.max(center.y, size.y * 0.4);
        controls.update();

        // 모델 최대 치수
        const maxDim = Math.max(size.x, size.y, size.z);
        const fov = camera.fov * Math.PI / 180;
        const fitDist = (maxDim / 2) / Math.tan(fov / 2); // 카메라가 모델을 담기 위한 기준 거리

        camera.position.set(center.x, center.y + maxDim * 0.25, center.z + fitDist * padding);
        camera.near = Math.max(0.00001, maxDim / 1/10);
        camera.far  = Math.max(500,  maxDim * 200);
        camera.updateProjectionMatrix();

        // 너무 가까이 못 가게 (클리핑 방지)
        controls.minDistance = fitDist * 0.02;  // 이 값보다 더 가까이 줌 불가
        controls.maxDistance = fitDist * 6;    // 과도하게 멀어지는 것도 제한
      }

      // 초기 로드 & 세팅
      (async () => {
        const a = await loadModel(MODELS[0]);
        const b = await loadModel(MODELS[1]);
        models.push(a, b);

        // 첫 모델 표시 + 프레이밍
        models[0].visible = true;
        frameToObject(models[0]);

        // 버튼 토글
        swapBtn.addEventListener('click', () => {
          models[current].visible = false;
          current = (current + 1) % models.length;
          models[current].visible = true;
          frameToObject(models[current]); // 전환 시마다 카메라/거리 재설정
          swapBtn.textContent = current === 0 ? '다른 모델 보기 ▶' : '처음 모델로 ◀';
        });
      })();

      // 리사이즈
      window.addEventListener('resize', () => {
        const w = container.clientWidth, h = container.clientHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
      });

      // 루프
      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }
      animate();
    </script>



<!-- 슬라이더_____________________________________________________________________________________________________ -->
    <script>
    // ===== 수동 슬라이더 =====
    const slider = document.getElementById('slider');
    const sliderDots = document.getElementById('sliderDots');

    const slides = Array.from(slider.querySelectorAll('.slider-item'));
    const slideCount = slides.length;

    function buildSliderDots() {
      sliderDots.innerHTML = '';
      for (let i = 0; i < slideCount; i++) {
        const dot = document.createElement('div');
        dot.className = 'dot' + (i === 0 ? ' active' : '');
        dot.addEventListener('click', () => goToSlide(i));
        sliderDots.appendChild(dot);
      }
    }

    function currentSlideIndex() {
      const w = slider.clientWidth;
      return Math.round(slider.scrollLeft / w);
    }

    function goToSlide(index) {
      const clamped = Math.max(0, Math.min(slideCount - 1, index));
      slider.scrollTo({ left: clamped * slider.clientWidth, behavior: 'smooth' });
      updateSliderDots(clamped);
    }

    function updateSliderDots(activeIndex = currentSlideIndex()) {
      const dots = sliderDots.querySelectorAll('.dot');
      dots.forEach((dot, i) => dot.classList.toggle('active', i === activeIndex));
    }

    // 스크롤 시 활성 도트 갱신
    slider.addEventListener('scroll', () => updateSliderDots());

    // 드래그/스와이프
    let isDown = false, startX = 0, startScrollLeft = 0, dragDelta = 0;

    const startDrag = (e) => {
      isDown = true;
      startX = (e.touches ? e.touches[0].pageX : e.pageX);
      startScrollLeft = slider.scrollLeft;
      dragDelta = 0;
    };
    const moveDrag = (e) => {
      if (!isDown) return;
      const x = (e.touches ? e.touches[0].pageX : e.pageX);
      dragDelta = x - startX;
      slider.scrollLeft = startScrollLeft - dragDelta;
    };
    const endDrag = () => {
      if (!isDown) return;
      isDown = false;
      const threshold = slider.clientWidth * 0.15; // 15% 이상 드래그 시 페이지 넘김
      let index = currentSlideIndex();
      if (Math.abs(dragDelta) > threshold) {
        index = dragDelta < 0 ? index + 1 : index - 1;
      }
      goToSlide(index);
    };

    slider.addEventListener('mousedown', startDrag);
    slider.addEventListener('mousemove', moveDrag);
    slider.addEventListener('mouseup', endDrag);
    slider.addEventListener('mouseleave', endDrag);
    slider.addEventListener('touchstart', startDrag, { passive: true });
    slider.addEventListener('touchmove', moveDrag, { passive: true });
    slider.addEventListener('touchend', endDrag);

    // 초기화
    buildSliderDots();
    updateSliderDots(0);

    // 리사이즈 시 현재 인덱스로 다시 스냅
    window.addEventListener('resize', () => {
      goToSlide(currentSlideIndex());
    });

    // ===== 자동 캐로셀 (도트 없음) =====
    const carousel = document.getElementById('carousel');
    const carouselItems = Array.from(carousel.querySelectorAll('.carousel-item'));
    const carouselCount = carouselItems.length;
    let currentIndex = 0;

    function autoSlide() {
      currentIndex = (currentIndex + 1) % carouselCount;
      carousel.style.transform = `translateX(-${currentIndex * 100}%)`;
    }

    setInterval(autoSlide, 4000);
  </script>
        
</body>
</html>
