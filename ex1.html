<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>GLB 보기</title>
    <style>
      body { margin:0; overflow:hidden; background-color:#bd5c5c; }
      #viewer { width:100%; height:1540px; background:#fff; position:relative; }
      canvas { display:block; }
      #swapBtn {
        position:absolute; top:16px; right:16px; z-index:10;
        padding:10px 14px; border:1px solid #ddd; border-radius:10px;
        background:#111; color:#fff; cursor:pointer; font-size:14px; opacity:.92;
      }
      #swapBtn:hover { opacity:1; }
    </style>

    <script type="importmap">
    { "imports": {
        "three":"https://unpkg.com/three@0.161.0/build/three.module.js",
        "three/addons/":"https://unpkg.com/three@0.161.0/examples/jsm/"
    } }
    </script>
  </head>

  <body>
    <div id="viewer">
      <button id="swapBtn">다른 모델 보기 ▶</button>
    </div>

    <script type="module">
      import * as THREE from 'three';
      import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

      const container = document.getElementById('viewer');
      const swapBtn   = document.getElementById('swapBtn');

      // ── 장면/카메라/렌더러 ─────────────────────────────────────────────
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffffff);

      const camera = new THREE.PerspectiveCamera(
        35, // ↓ 원근감 완화 (기존 60보다 덜 왜곡)
        container.clientWidth / container.clientHeight,
        0.01,  // 가까운 면 (클리핑 방지)
        5000   // 먼 면
      );
      camera.position.set(0, 1.2, 3);

      const renderer = new THREE.WebGLRenderer({ antialias:true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      container.appendChild(renderer.domElement);

      // ── 조명 ──────────────────────────────────────────────────────────
      scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 3.3));
      const dir = new THREE.DirectionalLight(0xffffff, 3.6);
      dir.position.set(3,10,10);
      scene.add(dir);

      // ── 컨트롤 ────────────────────────────────────────────────────────
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      // controls.minPolarAngle = Math.PI / 2; controls.maxPolarAngle = Math.PI / 2; // 좌우만 회전 비활성화

    //모델
      const MODELS = [
        {
          url: 'https://yooningu.github.io/ar.js-test/gltf/cat-glb/p-cat.glb',
          scale: 0.01,
          position: { x: 0,   y: 0,   z: 0 },
          rotation: { x: 0,   y: 0,   z: 0 }
        },
        {
          url: 'https://yooningu.github.io/ar.js-test/gltf/cat-glb/cat-glb.glb',
          scale: 0.001,
          position: { x: 0, y: 0,   z: 0 },          // 위치
          rotation: { x: 0, y:0, z: 0 }     //각도
        }
      ];

      const loader = new GLTFLoader();
      const models = [];
      let current = 0;

      // 모델 로드 & 준비
      async function loadModel({ url, scale, position, rotation }) {
        const gltf = await loader.loadAsync(url);
        const model = gltf.scene;
        model.scale.setScalar(scale);

        // 중앙/바닥 정렬 (원점에 모델 중심+바닥 맞춤)
        const box = new THREE.Box3().setFromObject(model);
        const center = box.getCenter(new THREE.Vector3());
        model.position.set(-center.x, -box.min.y, -center.z);

        // 사용자 위치/회전 적용
        model.position.add(new THREE.Vector3(position.x, position.y, position.z));
        model.rotation.set(rotation.x, rotation.y, rotation.z);

        model.visible = false;
        scene.add(model);
        return model;
      }

      // 모델 크기 기반으로 카메라/컨트롤 세팅 (투시 완화 + 과도 확대 방지)
      function frameToObject(object, padding = 1.6) {
        const box = new THREE.Box3().setFromObject(object);
        const size = box.getSize(new THREE.Vector3());
        const center = box.getCenter(new THREE.Vector3());

        // 컨트롤 타겟을 모델 중심 근처로
        controls.target.copy(center);
        controls.target.y = Math.max(center.y, size.y * 0.4);
        controls.update();

        // 모델 최대 치수
        const maxDim = Math.max(size.x, size.y, size.z);
        const fov = camera.fov * Math.PI / 180;
        const fitDist = (maxDim / 2) / Math.tan(fov / 2); // 카메라가 모델을 담기 위한 기준 거리

        camera.position.set(center.x, center.y + maxDim * 0.25, center.z + fitDist * padding);
        camera.near = Math.max(0.01, maxDim / 1000);
        camera.far  = Math.max(500,  maxDim * 50);
        camera.updateProjectionMatrix();

        // 너무 가까이 못 가게 (클리핑 방지)
        controls.minDistance = fitDist * 0.8;  // 이 값보다 더 가까이 줌 불가
        controls.maxDistance = fitDist * 6;    // 과도하게 멀어지는 것도 제한
      }

      // 초기 로드 & 세팅
      (async () => {
        const a = await loadModel(MODELS[0]);
        const b = await loadModel(MODELS[1]);
        models.push(a, b);

        // 첫 모델 표시 + 프레이밍
        models[0].visible = true;
        frameToObject(models[0]);

        // 버튼 토글
        swapBtn.addEventListener('click', () => {
          models[current].visible = false;
          current = (current + 1) % models.length;
          models[current].visible = true;
          frameToObject(models[current]); // 전환 시마다 카메라/거리 재설정
          swapBtn.textContent = current === 0 ? '다른 모델 보기 ▶' : '처음 모델로 ◀';
        });
      })();

      // 리사이즈
      window.addEventListener('resize', () => {
        const w = container.clientWidth, h = container.clientHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
      });

      // 루프
      function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
      }
      animate();
    </script>
  </body>
</html>
